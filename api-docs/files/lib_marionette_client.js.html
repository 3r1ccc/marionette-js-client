<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib&#x2F;marionette&#x2F;client.js - Marionette JS Client</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
          <h1>
            Marionette JS Client
          </h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Marionette.Client.html">Marionette.Client</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.CommandStream.html">Marionette.CommandStream</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Drivers.Abstract.html">Marionette.Drivers.Abstract</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Drivers.Httpd.html">Marionette.Drivers.Httpd</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Drivers.MozTcp.html">Marionette.Drivers.MozTcp</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Drivers.Tcp.html">Marionette.Drivers.Tcp</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Drivers.Websocket.html">Marionette.Drivers.Websocket</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Element.html">Marionette.Element</a></li>
            
                <li><a href="..&#x2F;classes/Marionette.Xhr.html">Marionette.Xhr</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib&#x2F;marionette&#x2F;client.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(module, ns) {

  var Element = ns.require(&#x27;element&#x27;),
      Exception = ns.require(&#x27;error&#x27;);

  var key;
  var searchMethods = {
    CLASS: &#x27;class name&#x27;,
    SELECTOR: &#x27;css selector&#x27;,
    ID: &#x27;id&#x27;,
    NAME: &#x27;name&#x27;,
    LINK_TEXT: &#x27;link text&#x27;,
    PARTIAL_LINK_TEXT: &#x27;partial link text&#x27;,
    TAG: &#x27;tag name&#x27;,
    XPATH: &#x27;xpath&#x27;
  };

  function isFunction(value) {
    return typeof(value) === &#x27;function&#x27;;
  }

  &#x2F;**
   * Initializes client.
   * You must create and initialize
   * a driver and pass it into the client before
   * using the client itself.
   *
   *     &#x2F;&#x2F; all drivers conform to this api
   *
   *     var driver = new Marionette.Dirver.MozTcp({});
   *     var client;
   *
   *     driver.connect(function(err) {
   *       if (err) {
   *         &#x2F;&#x2F; handle error case...
   *       }
   *
   *       client = new Marionette.Client(driver, {
   *           &#x2F;&#x2F; optional default callback can be used to implement
   *           &#x2F;&#x2F; a generator interface or other non-callback based api.
   *          defaultCallback: function(err, result) {
   *            console.log(&#x27;CALLBACK GOT:&#x27;, err, result);
   *          }
   *       });
   *
   *       &#x2F;&#x2F; by default commands run in a queue.
   *       &#x2F;&#x2F; assuming there is not a fatal error each command
   *       &#x2F;&#x2F; will execute sequentially.
   *       client.startSession().
   *              goUrl(&#x27;http:&#x2F;&#x2F;google.com&#x27;).
   *              executeScript(function() {
   *                alert(document.title);
   *              });
   *       }
   *     });
   *
   *
   * @class Marionette.Client
   * @constructor
   * @param {Marionette.Drivers.Abstract} driver fully initialized client.
   * @param {Object} options options for driver.
   *&#x2F;
  function Client(driver, options) {
    if (typeof(options) === &#x27;undefined&#x27;) {
      options = {};
    }
    this.driver = driver;
    this.defaultCallback = options.defaultCallback || false;
  }

  Client.prototype = {

    &#x2F;**
     * Constant for chrome context.
     *
     * @type {String}
     * @property CHROME
     *&#x2F;
    CHROME: &#x27;chrome&#x27;,

    &#x2F;**
     * Constant for content context.
     *
     * @type {String}
     * @property CONTENT
     *&#x2F;
    CONTENT: &#x27;content&#x27;,

    &#x2F;**
     * Actor id for instance
     *
     * @property actor
     * @type String
     *&#x2F;
    actor: null,

    &#x2F;**
     * Session id for instance.
     *
     * @property session
     * @type String
     *&#x2F;
    session: null,

    &#x2F;**
     * Sends a command to the server.
     * Adds additional information like actor and session
     * to command if not present.
     *
     *
     * @method send
     * @chainable
     * @param {Function} cb executed when response is sent.
     *&#x2F;
    send: function send(cmd, cb) {
      if (!cmd.to) {
        cmd.to = this.actor || &#x27;root&#x27;;
      }

      if (this.session) {
        cmd.session = cmd.session || this.session;
      }

      if (!cb &amp;&amp; this.defaultCallback) {
        cb = this.defaultCallback();
      }

      this.driver.send(cmd, cb);

      return this;
    },

    _handleCallback: function() {
      var args = Array.prototype.slice.call(arguments),
          callback = args.shift();

      if (!callback) {
        callback = this.defaultCallback;
      }

      &#x2F;&#x2F; handle error conversion
      if (args[0]) {
        args[0] = Exception.error(args[0]);
      }

      callback.apply(this, args);
    },

    &#x2F;**
     * Sends request and formats response.
     *
     *
     * @private
     * @method _sendCommand
     * @chainable
     * @param {Object} command marionette command.
     * @param {String} responseKey the part of the response to pass \
     *                             unto the callback.
     * @param {Object} callback wrapped callback.
     *&#x2F;
    _sendCommand: function(command, responseKey, callback) {
      var self = this;

      this.send(command, function(data) {
        var value = self._transformResultValue(data[responseKey]);
        self._handleCallback(callback, data.error, value);
      });
      return this;
    },

    &#x2F;**
     * Finds the actor for this instance.
     *
     * @private
     * @method _getActorId
     * @param {Function} callback executed when response is sent.
     *&#x2F;
    _getActorId: function _getActorId(callback) {
      var self = this, cmd;

      cmd = { type: &#x27;getMarionetteID&#x27; };

      return this._sendCommand(cmd, &#x27;id&#x27;, function(err, actor) {
        self.actor = actor;
        if (callback) {
          callback(err, actor);
        }
      });
    },

    &#x2F;**
     * Starts a remote session.
     *
     * @private
     * @method _newSession
     * @param {Function} callback optional.
     *&#x2F;
    _newSession: function _newSession(callback) {
      var self = this;

      function newSession(data) {
        self.session = data.value;
        self._handleCallback(callback, data.error, data);
      }

      this.send({ type: &#x27;newSession&#x27; }, newSession);
    },

    &#x2F;**
     * Finds actor and creates connection to marionette.
     * This is a combination of calling getMarionetteId and then newSession.
     *
     * @method startSession
     * @param {Function} callback executed when session is started.
     *&#x2F;
    startSession: function startSession(callback) {
      var self = this;
      return this._getActorId(function() {
        &#x2F;&#x2F;actor will not be set if we send the command then
        self._newSession(callback);
      });
    },

    &#x2F;**
     * Destroys current session.
     *
     *
     * @chainable
     * @method deleteSession
     * @param {Function} callback executed when session is destroyed.
     *&#x2F;
    deleteSession: function destroySession(callback) {
      var cmd = { type: &#x27;deleteSession&#x27; },
          self = this;

      this._sendCommand(cmd, &#x27;ok&#x27;, function(err, value) {
        self.driver.close();
        self._handleCallback(callback, err, value);
      });

      return this;
    },

    &#x2F;**
     * Callback will receive the id of the current window.
     *
     * @chainable
     * @method getWindow
     * @param {Function} callback executed with id of current window.
     * @return {Object} self.
     *&#x2F;
    getWindow: function getWindow(callback) {
      var cmd = { type: &#x27;getWindow&#x27; };
      return this._sendCommand(cmd, &#x27;value&#x27;, callback);
    },

    &#x2F;**
     * Callback will receive an array of window ids.
     *
     * @method getWindow
     * @chainable
     * @param {Function} callback executes with an array of ids.
     *&#x2F;
    getWindows: function getWindows(callback) {
      var cmd = { type: &#x27;getWindows&#x27; };
      return this._sendCommand(cmd, &#x27;value&#x27;, callback);
    },

    &#x2F;**
     * Switches context of marionette to specific window.
     *
     *
     * @method switchToWindow
     * @chainable
     * @param {String} id window id you can find these with getWindow(s).
     * @param {Function} callback called with boolean.
     *&#x2F;
    switchToWindow: function switchToWindow(id, callback) {
      var cmd = { type: &#x27;switchToWindow&#x27;, value: id };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Imports a script into the marionette
     * context for the duration of the session.
     *
     * Good for prototyping new marionette commands.
     *
     * @method importScript
     * @chainable
     * @param {String} script javascript string blob.
     * @param {Function} callback called with boolean.
     *&#x2F;
    importScript: function(script, callback) {
      var cmd = { type: &#x27;importScript&#x27;, script: script };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Switches context of marionette to specific iframe.
     *
     *
     * @method switchToFrame
     * @chainable
     * @param {String|Marionette.Element} id iframe id or element.
     * @param {Function} callback called with boolean.
     *&#x2F;
    switchToFrame: function switchToFrame(id, callback) {
      var cmd = { type: &#x27;switchToFrame&#x27; };

      if (id instanceof Element) {
        cmd.element = id.id;
      } else {
        cmd.value = id;
      }

      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Switches context of window.
     *
     * @method setContext
     * @chainable
     * @param {String} context either: &#x27;chome&#x27; or &#x27;content&#x27;.
     * @param {Function} callback receives boolean.
     *&#x2F;
    setContext: function setContext(content, callback) {
      if (content !== this.CHROME &amp;&amp; content !== this.CONTENT) {
        throw new Error(&#x27;content type must be &quot;chrome&quot; or &quot;content&quot;&#x27;);
      }

      var cmd = { type: &#x27;setContext&#x27;, value: content };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Sets the script timeout
     *
     * @method setScriptTimeout
     * @chainable
     * @param {Numeric} timeout max time in ms.
     * @param {Function} callback executed with boolean status.
     * @return {Object} self.
     *&#x2F;
    setScriptTimeout: function setScriptTimeout(timeout, callback) {
      var cmd = { type: &#x27;setScriptTimeout&#x27;, value: timeout };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * setSearchTimeout
     *
     * @method setSearchTimeout
     * @chainable
     * @param {Numeric} timeout max time in ms.
     * @param {Function} callback executed with boolean status.
     * @return {Object} self.
     *&#x2F;
    setSearchTimeout: function setSearchTimeout(timeout, callback) {
      var cmd = { type: &#x27;setSearchTimeout&#x27;, value: timeout };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Gets url location for device.
     *
     * @method getUrl
     * @chainable
     * @param {Function} callback receives url.
     *&#x2F;
    getUrl: function getUrl(callback) {
      var cmd = { type: &#x27;getUrl&#x27; };
      return this._sendCommand(cmd, &#x27;value&#x27;, callback);
    },

    &#x2F;**
     * Refreshes current window on device.
     *
     * @method refresh
     * @param {Function} callback boolean success.
     * @return {Object} self.
     *&#x2F;
    refresh: function refresh(callback) {
      var cmd = { type: &#x27;refresh&#x27; };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Drives browser to a url.
     *
     * @method goUrl
     * @chainable
     * @param {String} url location.
     * @param {Function} callback executes when finished driving browser to url.
     *&#x2F;
    goUrl: function goUrl(url, callback) {
      var cmd = { type: &#x27;goUrl&#x27;, value: url };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Drives window forward.
     *
     *
     * @method goForward
     * @chainable
     * @param {Function} callback receives boolean.
     *&#x2F;
    goForward: function goForward(callback) {
      var cmd = { type: &#x27;goForward&#x27; };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Drives window back.
     *
     * @method goBack
     * @chainable
     * @param {Function} callback receives boolean.
     *&#x2F;
    goBack: function goBack(callback) {
      var cmd = { type: &#x27;goBack&#x27; };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Logs a message on marionette server.
     *
     *
     * @method log
     * @chainable
     * @param {String} message log message.
     * @param {String} level arbitrary log level.
     * @param {Function} callback receives boolean.
     * @return {Object} self.
     *&#x2F;
    log: function log(msg, level, callback) {
      var cmd = { type: &#x27;log&#x27;, level: level, value: msg };
      return this._sendCommand(cmd, &#x27;ok&#x27;, callback);
    },

    &#x2F;**
     * Retrieves all logs on the marionette server.
     * The response from marionette is an array of arrays.
     *
     *     device.getLogs(function(err, logs){
     *       &#x2F;&#x2F;logs =&gt; [
     *         [
     *           &#x27;msg&#x27;,
     *           &#x27;level&#x27;,
     *           &#x27;Fri Apr 27 2012 11:00:32 GMT-0700 (PDT)&#x27;
     *         ]
     *       ]
     *     });
     *
     *
     * @method getLogs
     * @chainable
     * @param {Function} callback receive an array of logs.
     *&#x2F;
    getLogs: function getLogs(callback) {
      var cmd = { type: &#x27;getLogs&#x27; };
      return this._sendCommand(cmd, &#x27;value&#x27;, callback);
    },

    &#x2F;**
     * Executes a remote script will block.
     * Script is *not* wrapped in a function.
     *
     * @method executeJsScript
     * @chainable
     * @param {String} script script to run.
     * @param {Array} [args] optional args for script.
     * @param {Array} [timeout] optional args for timeout.
     * @param {Function} callback will receive result of the return \
     *                            call in the script if there is one.
     * @return {Object} self.
     *&#x2F;
    executeJsScript: function executeJsScript(script, args, timeout, callback) {
      if (typeof(timeout) === &#x27;function&#x27;) {
        callback = timeout;
        timeout = null;
      }
      if (typeof(args) === &#x27;function&#x27;) {
        callback = args;
        args = null;
      }

      timeout = (typeof(timeout) === &#x27;boolean&#x27;) ? timeout : true;

      return this._executeScript({
        type: &#x27;executeJSScript&#x27;,
        value: script,
        timeout: timeout,
        args: args
      }, callback || this.defaultCallback);
    },

    &#x2F;**
     * Executes a remote script will block. Script is wrapped in a function.
     *
     *     &#x2F;&#x2F; its is very important to remember that the contents of this
     *     &#x2F;&#x2F; method are &quot;stringified&quot; (Function#toString) and sent over the
     *     &#x2F;&#x2F; wire to execute on the device. So things like scope will not be
     *     &#x2F;&#x2F; the same. If you need to pass other information in arguments
     *     &#x2F;&#x2F; option should be used.
     *
     *     &#x2F;&#x2F; assume that this element is the result of findElement
     *     var element;
     *     var config = {
     *        event: &#x27;magicCustomEvent&#x27;,
     *        detail: { foo: true  }
     *     };
     *
     *     var remoteArgs = [element, details];
     *
     *     &#x2F;&#x2F; unlike other callbacks this one will execute _on device_
     *     function remoteFn(element, details) {
     *        &#x2F;&#x2F; element in this context is a real dom element now.
     *        var event = document.createEvent(&#x27;CustomEvent&#x27;);
     *        event.initCustomEvent(config.event, true, true, event.detail);
     *        element.dispatchEvent(event);
     *
     *        return { success: true };
     *     }
     *
     *     client.executeJsScript(remoteFn, remoteArgs, function(err, value) {
     *       &#x2F;&#x2F; value =&gt; { success: true }
     *     });
     *
     *
     * @method executeScript
     * @chainable
     * @param {String} script script to run.
     * @param {Array} [args] optional args for script.
     * @param {Function} callback will receive result of the return \
     *                            call in the script if there is one.
     * @return {Object} self.
     *&#x2F;
    executeScript: function executeScript(script, args, callback) {
      if (typeof(args) === &#x27;function&#x27;) {
        callback = args;
        args = null;
      }
      return this._executeScript({
        type: &#x27;executeScript&#x27;,
        value: script,
        args: args
      }, callback || this.defaultCallback);
    },

    &#x2F;**
     * Script is wrapped in a function and will be executed asynchronously.
     *
     * NOTE: that setScriptTimeout _must_ be set prior to using this method
     *       as the timeout defaults to zero.
     *
     *
     *    function remote () {
     *      window.addEventListener(&#x27;someevent&#x27;, function() {
     *        &#x2F;&#x2F; special method to notify that async script is complete.
     *        marionetteScriptFinished({ fromRemote: true })
     *      });
     *    }
     *
     *    client.executeAsyncScript(remote, function(err, value) {
     *      &#x2F;&#x2F; value === { fromRemote: true }
     *    });
     *
     *
     * @method executeAsyncScript
     * @chainable
     * @param {String} script script to run.
     * @param {Array} [args] optional args for script.
     * @param {Function} callback will receive result of the return \
     *                            call in the script if there is one.
     * @return {Object} self.
     *&#x2F;
    executeAsyncScript: function executeAsyncScript(script, args, callback) {
      if (typeof(args) === &#x27;function&#x27;) {
        callback = args;
        args = null;
      }
      return this._executeScript({
        type: &#x27;executeAsyncScript&#x27;,
        value: script,
        args: args
      }, callback || this.defaultCallback);
    },

    &#x2F;**
     * Finds element.
     *
     * @method _findElement
     * @private
     * @param {String} type type of command to send like &#x27;findElement&#x27;.
     * @param {String} query search query.
     * @param {String} method search method.
     * @param {String} elementId id of element to search within.
     * @param {Function} callback executes with element uuid(s).
     *&#x2F;
    _findElement: function _findElement(type, query, method, id, callback) {
      var cmd, self = this;

      if (isFunction(id)) {
        callback = id;
        id = undefined;
      }

      if (isFunction(method)) {
        callback = method;
        method = undefined;
      }

      callback = callback || this.defaultCallback;

      cmd = {
        type: type || &#x27;findElement&#x27;,
        using: method || &#x27;css selector&#x27;,
        value: query,
        element: id
      };

      if (this.searchMethods.indexOf(cmd.using) === -1) {
        throw new Error(
          &#x27;invalid option for using: \&#x27;&#x27; + cmd.using + &#x27;\&#x27; use one of : &#x27; +
          this.searchMethods.join(&#x27;, &#x27;)
        );
      }

      &#x2F;&#x2F;proably should extract this function into a private
      return this._sendCommand(cmd, &#x27;value&#x27;,
                               function processElements(err, result) {
        var element;

        if (result instanceof Array) {
          element = [];
          result.forEach(function(el) {
            element.push(new Element(el, self));
          });
        } else {
          element = new Element(result, self);
        }
        self._handleCallback(callback, err, element);
      });
    },

    &#x2F;**
     * Attempts to find a dom element (via css selector, xpath, etc...)
     * &quot;elements&quot; returned are instances of
     * {{#crossLink &quot;Marionette.Element&quot;}}{{&#x2F;crossLink}}
     *
     *
     *     &#x2F;&#x2F; with default options
     *     client.findElement(&#x27;#css-selector&#x27;, function(err, element) {
     *        if (err) {
     *          &#x2F;&#x2F; handle case where element was not found
     *        }
     *
     *        &#x2F;&#x2F; see element interface for all methods, etc..
     *        element.click(function() {
     *
     *        });
     *     });
     *
     *
     *
     * @method findElement
     * @chainable
     * @param {String} query search query.
     * @param {String} method search method.
     * @param {String} elementId id of element to search within.
     * @param {Function} callback executes with element uuid.
     *&#x2F;
    findElement: function findElement() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(&#x27;findElement&#x27;);
      return this._findElement.apply(this, args);
    },

    &#x2F;**
     * Finds multiple elements in the dom. This method has the same
     * api signature as {{#crossLink &quot;findElement&quot;}}{{&#x2F;crossLink}} the
     * only difference is where findElement returns a single element
     * this method will return an array of elements in the callback.
     *
     *
     *     &#x2F;&#x2F; find all links in the document
     *     client.findElements(&#x27;a[href]&#x27;, function(err, element) {
     *     });
     *
     *
     * @method findElements
     * @chainable
     * @param {String} query search query.
     * @param {String} method search method.
     * @param {String} elementId id of element to search within.
     * @param {Function} callback executes with an array of element uuids.
     *&#x2F;
    findElements: function findElements() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(&#x27;findElements&#x27;);
      return this._findElement.apply(this, args);
    },


    &#x2F;**
     * Converts an function into a string
     * that can be sent to marionette.
     *
     * @private
     * @method _convertFunction
     * @param {Function|String} fn function to call on the server.
     * @return {String} function string.
     *&#x2F;
    _convertFunction: function _convertFunction(fn) {
      if (typeof(fn) === &#x27;function&#x27;) {
        var str = fn.toString();
        return &#x27;return (&#x27; + str + &#x27;.apply(this, arguments));&#x27;;
      }
      return fn;
    },

    &#x2F;**
     * Processes result of command
     * if an {&#x27;ELEMENT&#x27;: &#x27;uuid&#x27;} combination
     * is returned a Marionette.Element
     * instance will be created and returned.
     *
     *
     * @private
     * @method _transformResultValue
     * @param {Object} value original result from server.
     * @return {Object|Marionette.Element} processed result.
     *&#x2F;
    _transformResultValue: function _transformResultValue(value) {
      if (value &amp;&amp; typeof(value.ELEMENT) === &#x27;string&#x27;) {
        return new Element(value.ELEMENT, this);
      }
      return value;
    },

    &#x2F;**
     * Prepares arguments for script commands.
     * Formats Marionette.Element&#x27;s sod
     * marionette can use them in script commands.
     *
     *
     * @private
     * @method _prepareArguments
     * @param {Array} arguments list of args for wrapped function.
     * @return {Array} processed arguments.
     *&#x2F;
    _prepareArguments: function _prepareArguments(args) {
      if (args.map) {
        return args.map(function(item) {
          if (item instanceof Element) {
            return {&#x27;ELEMENT&#x27;: item.id };
          }
          return item;
        });
      } else {
        return args;
      }
    },

    &#x2F;**
     * Executes a remote string of javascript.
     * the javascript string will be wrapped in a function
     * by marionette.
     *
     *
     * @method _executeScript
     * @private
     * @param {Object} options objects of execute script.
     * @param {String} options.type command type like &#x27;executeScript&#x27;.
     * @param {String} options.value javascript string.
     * @param {String} options.args arguments for script.
     * @param {Boolean} options.timeout timeout only used in &#x27;executeJSScript&#x27;.
     * @param {Function} callback executes when script finishes.
     * @return {Object} self.
     *&#x2F;
    _executeScript: function _executeScript(options, callback) {
      var timeout = options.timeout,
          self = this,
          cmd = {
            type: options.type,
            value: this._convertFunction(options.value),
            args: this._prepareArguments(options.args || [])
          };

      if (timeout === true || timeout === false) {
        cmd.timeout = timeout;
      }

      return this._sendCommand(cmd, &#x27;value&#x27;, callback);
    }

  };


  &#x2F;&#x2F;gjslint: ignore
  var proto = Client.prototype;
  proto.searchMethods = [];

  for (key in searchMethods) {
    if (searchMethods.hasOwnProperty(key)) {
      Client.prototype[key] = searchMethods[key];
      Client.prototype.searchMethods.push(searchMethods[key]);
    }
  }

  module.exports = Client;

}.apply(
  this,
  (this.Marionette) ?
    [Marionette(&#x27;client&#x27;), Marionette] :
    [module, require(&#x27;.&#x2F;marionette&#x27;)]
));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
